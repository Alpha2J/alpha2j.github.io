<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis知识点总结 | 杰布是谁</title><meta name="author" content="Jeb"><meta name="copyright" content="Jeb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、安装、配置及Jedis客户端 安装：docker  配置：暂无  Jedis客户端：  12345&lt;dependency&gt;  &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;  &lt;version&gt;5.0.0&lt;&#x2F;version&gt;&amp;l">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis知识点总结">
<meta property="og:url" content="https://alpha2j.cn/2021/08/20/undefined/index.html">
<meta property="og:site_name" content="杰布是谁">
<meta property="og:description" content="一、安装、配置及Jedis客户端 安装：docker  配置：暂无  Jedis客户端：  12345&lt;dependency&gt;  &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;  &lt;version&gt;5.0.0&lt;&#x2F;version&gt;&amp;l">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://alpha2j.cn/assets/blog_avatar.jpeg">
<meta property="article:published_time" content="2021-08-20T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-24T14:41:07.236Z">
<meta property="article:author" content="Jeb">
<meta property="article:tag" content="notes">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://alpha2j.cn/assets/blog_avatar.jpeg"><link rel="shortcut icon" href="/assets/favicon.png"><link rel="canonical" href="https://alpha2j.cn/2021/08/20/undefined/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Jeb","link":"链接: ","source":"来源: 杰布是谁","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-24 22:41:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/blog_avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-house-user"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-graduate"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/about_en/"><i class="fa-fw fas fa-user-astronaut"></i><span> About Me</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/assets/default_top_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="杰布是谁"><span class="site-name">杰布是谁</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-house-user"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-layer-group"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-graduate"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/about_en/"><i class="fa-fw fas fa-user-astronaut"></i><span> About Me</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-08-20T16:00:00.000Z" title="发表于 2021-08-21 00:00:00">2021-08-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/technology/">technology</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、安装、配置及Jedis客户端"><a href="#一、安装、配置及Jedis客户端" class="headerlink" title="一、安装、配置及Jedis客户端"></a>一、安装、配置及Jedis客户端</h1><ol>
<li><p>安装：<a target="_blank" rel="noopener" href="https://hub.docker.com/_/redis">docker</a></p>
</li>
<li><p>配置：暂无</p>
</li>
<li><p>Jedis客户端：</p>
 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span> </span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h1><h2 id="2-1-字符串-string"><a href="#2-1-字符串-string" class="headerlink" title="2.1 字符串(string)"></a>2.1 字符串(string)</h2><p>字符串类型的值可以为字符串、数字或二进制。Redis提供命令支持常规的字符串操作，如<code>append</code>，<code>range</code>等。当实际类型为数字时，还可对它进行数学运算，如自增自减的原子操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自增1/自减1</span></span><br><span class="line"><span class="built_in">set</span> incr_t1 1</span><br><span class="line">incr incr_t1</span><br><span class="line">decr decr_t1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加指定值/减少指定值</span></span><br><span class="line"><span class="built_in">set</span> incrby_t1 1</span><br><span class="line">incrby incrby_t1 5</span><br><span class="line">decrby decrby_t1 2</span><br></pre></td></tr></table></figure>

<h2 id="2-2-列表-list"><a href="#2-2-列表-list" class="headerlink" title="2.2 列表(list)"></a>2.2 列表(list)</h2><p>每个节点都包含一个字符串，可以从链表的两端推入或者弹出元素等。</p>
<ul>
<li><code>lpush</code>，<code>rpush</code>：将元素推进左侧或者右侧。</li>
<li><code>lpop</code>，<code>rpop</code>：将元素从左端或者右端弹出。</li>
<li><code>lindex</code>：获取指定位置的元素。</li>
<li><code>lrange</code>：获取给定范围上的元素。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ----普通列表操作----</span></span><br><span class="line"><span class="comment"># rpush key value [value...]: 将一个或多个值推入列表的右端</span></span><br><span class="line"><span class="comment"># 推入一个值</span></span><br><span class="line">rpush rpushtest rpushtestvalue1</span><br><span class="line"><span class="comment"># 推入多个值</span></span><br><span class="line">rpush rpushtest rpushtestvalue2 rpushtestvalue3</span><br><span class="line"><span class="comment"># rpushtestvalue1 rpushtestvalue2 rpushtestvalue3</span></span><br><span class="line">lrange rpushtest 0 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># lpush key value [value...]: 将一个或多个值推入列表的左端</span></span><br><span class="line">lpush lpushtest lpushtestvalue1</span><br><span class="line">lpush lpushtest lpushtestvalue2 lpushtestvalue3</span><br><span class="line"><span class="comment"># lpushtestvalue3 lpushtestvalue2 lpushtestvalue1</span></span><br><span class="line">lrange lpushtest 0 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># rpop key: 移除并返回最右端的元素</span></span><br><span class="line">rpush rpoptest rpoptestvalue1 rpoptestvalue2 rpoptestvalue3</span><br><span class="line">rpop rpoptest</span><br><span class="line"><span class="comment"># rpoptestvalue1 rpoptestvalue2</span></span><br><span class="line">lrange rpoptest 0 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># lpop key: 移除并返回最左端的元素</span></span><br><span class="line">rpush lpoptest lpoptestvalue1 lpoptestvalue2 lpoptestvalue3</span><br><span class="line">lpop lpoptest</span><br><span class="line"><span class="comment"># lpoptestvalue2 lpoptestvalue3</span></span><br><span class="line">lrange lpoptest 0 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># lindex key offset: 返回下标为offset的元素</span></span><br><span class="line">lpush lindextest lindextestvalue1 lindextestvalue2 lindextestvalue3</span><br><span class="line"><span class="comment"># 注意这里造数据用的是lpush</span></span><br><span class="line"><span class="comment"># lindextestvalue3</span></span><br><span class="line">lindex lindextest 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># lrange key start end: 返回从start到end且包括start和end的元素</span></span><br><span class="line">lpush lrangetest lrangetestvalue1 lrangetestvalue2 lrangetestvalue3</span><br><span class="line"><span class="comment"># 注意这里造数据用的是lpush</span></span><br><span class="line"><span class="comment"># lrangetestvalue3 lrangetestvalue2 lrangetestvalue1</span></span><br><span class="line">lrange lrangetest 0 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># ltrim key start end: 修剪列表, 只保留从start到end且包括start和end的元素</span></span><br><span class="line">lpush ltrimtest ltrimtestvalue1 ltrimtestvalue2 ltrimtestvalue3</span><br><span class="line">ltrim ltrimtest 1 1</span><br><span class="line"><span class="comment"># ltrimtestvalue2</span></span><br><span class="line">lrange ltrimtest 0 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----阻塞式列表操作----</span></span><br><span class="line"><span class="comment"># 阻塞式列表操作会阻塞执行命令的客户端, 直到有其他客户端给列表添加元素为止. 对于阻塞弹出命令和弹出并推入命令, 最常见的用例就是消息传递(messaging)和任务队列(task queue).</span></span><br><span class="line"><span class="comment"># blpop key [key ...] timeout: 从第一个非空列表中弹出位于最左端的元素, 或者在timeout秒之内阻塞并等待可弹出的元素出现</span></span><br><span class="line"><span class="comment"># 在一个redis-cli下执行下方命令. 命令执行后这个redis-cli开始阻塞</span></span><br><span class="line">blpop blpoptest 100000</span><br><span class="line"><span class="comment"># 打开另一个redis-cli, 执行下方命令. 命令执行后立即看到前面一个redis-cli结束阻塞, 并输出结果</span></span><br><span class="line">lpush blpoptest blpoptestvalue</span><br><span class="line"></span><br><span class="line"><span class="comment"># brpop key [key ...] timeout: 和blpop类似, 但这个是从右边弹出</span></span><br><span class="line">brpop brpoptest 100000</span><br><span class="line">rpush brpoptest rpoptestvalue</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----列表间操作----</span></span><br><span class="line"><span class="comment"># rpoplpush source-key dest-key: 从source-key列表中弹出位于最右端的元素, 然后将这个元素推入dest-key列表的最左端</span></span><br><span class="line">lpush rpoplpush-src rpoplpush-srcValue</span><br><span class="line">rpoplpush rpoplpush-src rpoplpushtest-des</span><br><span class="line"><span class="comment"># rpoplpush-srcValue</span></span><br><span class="line">lindex rpoplpushtest-des 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># brpoplpush source-key dest-key timeout: 从source-key列表中弹出位于最右端的元素, 然后将这个元素推入dest-key列表的最左端. 如果source-key为空, 那么redis客户端将会阻塞等待timeout秒</span></span><br><span class="line"><span class="comment"># redis-cli 1</span></span><br><span class="line">brpoplpush brpoplpushtest-src brpoplpushtest-des 100000</span><br><span class="line"><span class="comment"># 打开另一个redis-cli 2</span></span><br><span class="line">lpush brpoplpushtest-src brpoplpushtest-srcValue</span><br><span class="line"><span class="comment"># brpoplpushtest-srcValue</span></span><br><span class="line">lindex brpoplpushtest-des 0</span><br></pre></td></tr></table></figure>

<h2 id="2-3-集合-set"><a href="#2-3-集合-set" class="headerlink" title="2.3 集合(set)"></a>2.3 集合(set)</h2><p>包含独一无二的字符串元素的数据结构，可以添加，获取或者移除单个元素，检查元素是否存在于集合中，<strong>计算交集，并集，差集，</strong>从集合里面随机获取元素等。</p>
<ul>
<li><code>sadd</code>：将元素添加到集合。</li>
<li><code>srem</code>：从集合里面移除元素。</li>
<li><code>sismember</code>：快速检查一个元素是否已经在集合中。</li>
<li><code>smembers</code>：获取集合包含的所有元素（如果集合包含的元素非常多，这个命令的执行速度可能会很慢，所以应该谨慎地使用这个命令）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ----基本集合操作----</span></span><br><span class="line"><span class="comment"># sadd key item [item ...]: 将一个或多个元素添加到集合里面</span></span><br><span class="line">sadd saddtest saddtestmember1 saddtestmember2</span><br><span class="line"><span class="comment"># saddtestmember1 saddtestmember2</span></span><br><span class="line">smembers saddtest</span><br><span class="line"></span><br><span class="line"><span class="comment"># srem key item [item ...]: 从集合里面移除一个或多个元素</span></span><br><span class="line">sadd sremtest sremtestvalue1 sremtestvalue2</span><br><span class="line"><span class="comment"># sremtestvalue1 sremtestvalue2</span></span><br><span class="line">smembers sremtest</span><br><span class="line">srem sremtest sremtestvalue1</span><br><span class="line"><span class="comment"># sremtestvalue2</span></span><br><span class="line">smembers sremtest</span><br><span class="line"></span><br><span class="line"><span class="comment"># sismember key item: 检查元素item是否在于集合key里面</span></span><br><span class="line">sadd sismembertest sismembertestvalue1 sismembertestvalue2</span><br><span class="line"><span class="comment"># 0 表示不在集合中</span></span><br><span class="line">sismember sismembertest aaa</span><br><span class="line"><span class="comment"># 1 表示在集合中</span></span><br><span class="line">sismember sismembertest sismembertestvalue1</span><br><span class="line"></span><br><span class="line"><span class="comment"># scard key: 返回集合包含的元素数量</span></span><br><span class="line">sadd scardtest scardtestvalue1 scardtestvalue2</span><br><span class="line"><span class="comment"># 2 两个元素</span></span><br><span class="line">scard scardtest</span><br><span class="line"></span><br><span class="line"><span class="comment"># smembers key: 返回集合包含的所有元素</span></span><br><span class="line">sadd smembertest smembertestvalue1 smembertestvalue2</span><br><span class="line"><span class="comment"># smembertestvalue1 smembertestvalue2</span></span><br><span class="line">smembers smembertest</span><br><span class="line"></span><br><span class="line"><span class="comment"># spop key: 随机地移除集合中的一个元素</span></span><br><span class="line"><span class="comment"># 先造多点测试数据</span></span><br><span class="line">sadd spoptest spoptestvalue1 spoptestvalue2</span><br><span class="line">sadd spoptest spoptestvalue3 spoptestvalue4</span><br><span class="line">sadd spoptest spoptestvalue5 spoptestvalue6</span><br><span class="line">sadd spoptest spoptestvalue7 spoptestvalue8</span><br><span class="line"><span class="comment"># 会随机移除一个元素, 并返回这个移除的元素</span></span><br><span class="line">spop spoptest</span><br><span class="line"></span><br><span class="line"><span class="comment"># smove source-key dest-key item: 如果source-key包含item, 那么从source-key中移除item, 并将item添加到集合dest-key中</span></span><br><span class="line">sadd smovetest-src smovetestValue1 smovetestValue2</span><br><span class="line">smove smovetest-src smovetest-dest smovetestValue2</span><br><span class="line"><span class="comment"># smovetestValue1</span></span><br><span class="line">smembers smovetest-src</span><br><span class="line"><span class="comment"># smovetestValue2</span></span><br><span class="line">smembers smovetest-dest</span><br><span class="line"></span><br><span class="line"><span class="comment"># ----处理多个集合操作----</span></span><br><span class="line"><span class="comment"># sdiff key [key ...]: 返回存在于第一个集合, 但不存在于其他集合中的元素(差集运算)</span></span><br><span class="line">sadd sdifftest-0 sdifftestValue1 sdifftestValue2</span><br><span class="line">sadd sdifftest-1 sdifftestValue1</span><br><span class="line"><span class="comment"># sdifftestValue2</span></span><br><span class="line">sdiff sdifftest-0 sdifftest-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># sdiffstore dest-key key [key ...]: 将存在于第一个集合, 但不存在于其他集合中的元素存储到dest-key键里面</span></span><br><span class="line">sadd sdiffstoretest-0 sdiffstoretestValue1 sdiffstoretestValue2</span><br><span class="line">sadd sdiffstoretest-1 sdiffstoretestValue1</span><br><span class="line">sdiffstore sdiffstoretest-dest sdiffstoretest-0 sdiffstoretest-1</span><br><span class="line"><span class="comment"># sdiffstoretestValue2</span></span><br><span class="line">smembers sdiffstoretest-dest</span><br><span class="line"></span><br><span class="line"><span class="comment"># sinter key [key ...]: 返回同时存在于所有集合中的元素(交集运算)</span></span><br><span class="line">sadd sintertest-0 sintertestValue1 sintertestValue2</span><br><span class="line">sadd sintertest-1 sintertestValue2 sintertestValue3</span><br><span class="line"><span class="comment"># sintertestValue2</span></span><br><span class="line">sinter sintertest-0 sintertest-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># sinterstore dest-key key [key ...]: 将同时存在于所有集合中的元素存储到dest-key键里面</span></span><br><span class="line">sadd sinterstoretest-0 sinterstoretestValue1 sinterstoretestValue2</span><br><span class="line">sadd sinterstoretest-1 sinterstoretestValue2 sinterstoretestValue3</span><br><span class="line">sinterstore sinterstoretest-dest sinterstoretest-0 sinterstoretest-1</span><br><span class="line"><span class="comment"># sinterstoretestValue2</span></span><br><span class="line">smembers sinterstoretest-dest</span><br><span class="line"></span><br><span class="line"><span class="comment"># sunion key [key ...]: 返回至少存在于一个集合中的元素(并集操作)</span></span><br><span class="line">sadd suniontest-0 suniontestValue1 suniontestValue2</span><br><span class="line">sadd suniontest-1 suniontestValue2 suniontestValue3</span><br><span class="line"><span class="comment"># suniontestValue1 suniontestValue2 suniontestValue3</span></span><br><span class="line">sunion suniontest-0 suniontest-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># sunionstore dest-key key [key ...]: 将至少存在于一个集合中的元素存储到dest-key键里面</span></span><br><span class="line">sadd sunionstoretest-0 sunionstoretestValue1 sunionstoretestValue2</span><br><span class="line">sadd sunionstoretest-1 sunionstoretestValue2 sunionstoretestValue3</span><br><span class="line">sunionstore sunionstoretest-dest sunionstoretest-0 sunionstoretest-1</span><br><span class="line"><span class="comment"># sunionstoretestValue1 sunionstoretestValue2 sunionstoretestValue3</span></span><br><span class="line">smembers sunionstoretest-dest</span><br></pre></td></tr></table></figure>

<h2 id="2-4-哈希-hash"><a href="#2-4-哈希-hash" class="headerlink" title="2.4 哈希(hash)"></a>2.4 哈希(hash)</h2><ul>
<li><code>hset</code>：将一个键值对添加到一个hashmap中。</li>
<li><code>hget</code>：获取指定hashmap中指定键的键值对的值。</li>
<li><code>hgetall</code>：获取指定hashmap中所有键值对。</li>
<li><code>hdel</code>：删除指定键值对中指定的键的键值对。</li>
</ul>
<p>注意：如果想要获取所有键值对，<code>hgetall</code>和<code>hkeys</code>与<code>hvals</code>都能实现相同的功能，但是如果散列包含的值非常大，那么可以先使用<code>hkeys</code>取出包含的所有键，然后再使用<code>hget</code>一个接一个地去除键的值，从而避免一次获取多个大体积的值导致服务器阻塞。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hmget key field1 [field2 ...]: 从散列key里面获取一个field或者多个field的值</span></span><br><span class="line">hmset hmgettest hmgettestField1 hmgettestValue1 hmgettestField2 hmgettestValue2</span><br><span class="line"><span class="comment"># hmgettestValue1 hmgettestValue2</span></span><br><span class="line">hmget hmgettest hmgettestField1 hmgettestField2</span><br><span class="line"></span><br><span class="line"><span class="comment"># hmset key field1 fieldValue1 [field2 fieldValue2 ...]: 为散列里面的一个或多个键设置值</span></span><br><span class="line">hmset hmsettest hmsettestField1 hmsettestValue1 hmsettestField2 hmsettestValue2</span><br><span class="line"><span class="comment"># hmsettestValue1 hmsettestValue2</span></span><br><span class="line">hmget hmsettest hmsettestField1 hmsettestField2</span><br><span class="line"></span><br><span class="line"><span class="comment"># hdel key field1 [field2 ...] 删除散列key里面的一个或多个field</span></span><br><span class="line">hmset hdeltest hdeltestField1 hdeltestValue1 hdeltestField2 hdeltestValue2</span><br><span class="line">hdel hdeltest hdeltestField1</span><br><span class="line"><span class="comment"># nil 因为该field已经被删除了</span></span><br><span class="line">hmget hdeltest hdeltestField1</span><br><span class="line"></span><br><span class="line"><span class="comment"># hlen key: 返回散列key包含的值对数量</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">hmset hlentest hlentestField1 hlentestValue1 hlentestField2 hlentestValue2</span><br><span class="line">hlen hlentest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试数据供下面几个命令使用</span></span><br><span class="line">hmset hashtest hexistsTestField existsTestFieldValue hincrbyTestField 1 hincrbyfloatTestField 2</span><br><span class="line"><span class="comment"># hexists key field: 检查给定键是否存在于散列中</span></span><br><span class="line"><span class="comment"># 1 表示存在</span></span><br><span class="line">hexists hashtest hexistsTestField</span><br><span class="line"><span class="comment"># 0 表示不存在</span></span><br><span class="line">hexists hashtest hexistsTestField-noexists</span><br><span class="line"></span><br><span class="line"><span class="comment"># hkeys key: 获取散列包含的所有键</span></span><br><span class="line"><span class="comment"># hexistsTestField hincrbyTestField hincrbyfloatTestField</span></span><br><span class="line">hkeys hashtest</span><br><span class="line"></span><br><span class="line"><span class="comment"># hvals key: 获取散列包含的所有值</span></span><br><span class="line"><span class="comment"># existsTestFieldValue hincrbyTestValue hincrbyfloatTestValue</span></span><br><span class="line">hvals hashtest</span><br><span class="line"></span><br><span class="line"><span class="comment"># hgetall key: 获取散列包含的所有键值对</span></span><br><span class="line"><span class="comment"># hexistsTestField existsTestFieldValue ... 键值对的方式先后出现</span></span><br><span class="line">hgetall hashtest</span><br><span class="line"></span><br><span class="line"><span class="comment"># hincrby key field increment: 将键key的散列的field的值加上整数increment</span></span><br><span class="line"><span class="comment"># 4 表示现在的值为4</span></span><br><span class="line">hincrby hashtest hincrbyTestField 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># hincrbyfloat key field increment: 将键key的散列的field的值加上浮点数increment.</span></span><br><span class="line"><span class="comment"># 6.2 表示现在的值为6.2</span></span><br><span class="line">hincrbyfloat hashtest hincrbyfloatTestField 2.2</span><br></pre></td></tr></table></figure>

<h2 id="2-5-有序集合-zset"><a href="#2-5-有序集合-zset" class="headerlink" title="2.5 有序集合(zset)"></a>2.5 有序集合(zset)</h2><p>有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员(member)，<strong>每个成员都是各不相同的；</strong>而有序集合的值则称为分值(score)，<strong>分值必须为浮点数。</strong>有序集合是Redis里面唯一一个既可以根据成员访问元素，又可以根据分值以及分值的排列顺序来访问元素的结构。</p>
<ul>
<li><code>zadd</code>：添加一个元素，注意区分<code>member</code>和<code>score</code>。</li>
<li><code>zrange</code>：获取元素集合，可以根据分值进行排序：<code>zrange zset-key 0 -1 withscores</code>。</li>
<li><code>zrangebyscore</code>：根据分值来获取有序集合中的一部分元素。<code>zrangebyscore zset-key 0 800 withscores</code>：获取分值在0 到 800 的元素。</li>
<li><code>zrem</code>：如果给定成员存在有序集合，那么移除这个成员。</li>
</ul>
<p>散列存储的是键和值之间的映射，而有序集合存储的是成员与分值之间的映射，并提供了分值的处理命令。以及根据分值大小有序地获取或扫描成员和分值的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造测试数据</span></span><br><span class="line">zadd zsettest 1.9 member1 2.8 member2</span><br><span class="line"></span><br><span class="line"><span class="comment"># zadd key score member [score member ...]: 将带有给定分值的成员添加到有序集合里面</span></span><br><span class="line">zadd zsettest 1.2 member3 2.9 member4</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrem key member [member ...]: 从有序集合里面移除给定的成员, 并返回被移除成员的数量</span></span><br><span class="line">zrem zsettest member1</span><br><span class="line"></span><br><span class="line"><span class="comment"># zcard key: 返回有序集合包含的成员数量</span></span><br><span class="line">zcard zsettest</span><br><span class="line"></span><br><span class="line"><span class="comment"># zincrby key increment member</span></span><br><span class="line"><span class="comment"># zcount key min max</span></span><br><span class="line"><span class="comment"># zrank key member</span></span><br><span class="line"><span class="comment"># zscore key member</span></span><br><span class="line"><span class="comment"># zrange key start stop [withscores]: zrange key 0 -1 表示返回所有成员，不计算分值区间</span></span><br><span class="line"><span class="comment"># zrevrank key member</span></span><br><span class="line"><span class="comment"># zrevrange key start stop [withscores]</span></span><br><span class="line"><span class="comment"># srangebyscore key min max [withscores] [limit offset count]</span></span><br><span class="line"><span class="comment"># zrevrangebyscore key max min [withscores] [limit offset count]</span></span><br><span class="line"><span class="comment"># zremrangebyrank key start stop</span></span><br><span class="line"><span class="comment"># zremrangebyscore key min max</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-bitmaps"><a href="#2-6-bitmaps" class="headerlink" title="2.6 bitmaps"></a>2.6 bitmaps</h2><p>redis提供bitmaps来实现对位的操作，它不是一种数据结构，实际上它就是字符串。bitmaps单独提供了一套命令，所以在redis中使用bitmaps和使用字符串的方法不太相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line">setbit key offset value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下两条命令生成这样的bitmap：01001</span></span><br><span class="line">setbit bitmapstest 1 1</span><br><span class="line">setbit bitmapstest 4 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line">getbit bitmapstest 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定范围值为1的个数</span></span><br><span class="line">bitcount bitmapstest 5 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他操作：两个key交集并集等，第一个值为target的偏移量等操作，具体查文档</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-hyperloglog"><a href="#2-7-hyperloglog" class="headerlink" title="2.7 hyperloglog"></a>2.7 hyperloglog</h2><p>用在可容忍一定精准度下的统计操作。消耗的内存极小，大约为12kb。redis中它不是一种数据结构，实际上它就是字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方式</span></span><br><span class="line"><span class="comment"># 往hyperloglog中添加元素，成功返回1</span></span><br><span class="line">pfadd key element [elements ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算hyperloglog独立总数</span></span><br><span class="line">pfcount key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求出多个hyperloglog的并集并赋值给destkey</span></span><br><span class="line">pfmerge destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

<h2 id="2-8-geo"><a href="#2-8-geo" class="headerlink" title="2.8 geo"></a>2.8 geo</h2><p>支持存储地理位置信息的功能，存储的信息会包括地理位置的经度、纬度、成员。redis中它不是一种新的数据结构，实际上是zset。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加地理位置</span></span><br><span class="line">geoadd cities:locations 116.28 39.55 beijing</span><br><span class="line">geoadd cities:locations 102.11 35.12 shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取地理位置信息</span></span><br><span class="line">geopos cities:locations beijing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取两个地理位置间距离</span></span><br><span class="line">geodist cities:locations beijing shanghai</span><br></pre></td></tr></table></figure>

<h2 id="2-9-发布订阅"><a href="#2-9-发布订阅" class="headerlink" title="2.9 发布订阅"></a>2.9 发布订阅</h2><p>订阅者订阅频道，发送者负责向频道发送消息，每当有消息被发送至给定频道时，频道的所有订阅者都会收到消息。Redis提供如下五个发布与订阅命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例与描述</th>
</tr>
</thead>
<tbody><tr>
<td>subscribe</td>
<td>subscribe channel [channel …]: 订阅给定的一个或多个频道</td>
</tr>
<tr>
<td>unsubscribe</td>
<td>unsubscribe [channel [channel …]]: 退订给定的一个或多个频道, 如果执行时没有给定任何频道, 那么退订所有频道</td>
</tr>
<tr>
<td>publish</td>
<td>publish channel message: 向给定频道发送消息</td>
</tr>
<tr>
<td>psubscribe</td>
<td>psubscribe pattern [pattern …]: 订阅与给定模式相匹配的所有频道</td>
</tr>
<tr>
<td>punsubscribe</td>
<td>punsubscribe [pattern [pattern …]]: 退订给定的模式, 如果执行时没有给定任何模式, 那么退订所有模式</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在一个redis-cli中订阅两个频道:</span></span><br><span class="line">subscribe testchannel1 testchannel2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在另一个redis-cli中执行发布消息:</span></span><br><span class="line">publish testchannel1 <span class="string">&#x27;hello from publisher&#x27;</span></span><br><span class="line">publish testchannel2 <span class="string">&#x27;hello from the same publisher&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第一个redis-cli可以收到第二个redis-cli中发布的消息</span></span><br></pre></td></tr></table></figure>

<p>和专业消息队列系统比，无法实现消息堆积和回溯，负载均衡也是个问题。如果业务场景可以容忍这些问题，那么可以使用。</p>
<h2 id="2-10-事务"><a href="#2-10-事务" class="headerlink" title="2.10 事务"></a>2.10 事务</h2><p>redis中有5个事务相关的命令，分别是<code>watch</code>，<code>unwatch</code>，<code>multi</code>，<code>exec</code>和<code>discard</code>。事务可以让一个客户端在不被其他客户端打断的情况下执行多个命令。<strong>被<code>multi</code>命令和<code>exec</code>命令包围的所有命令会一个接一个地执行，直到所有命令都执行完毕为止，当一个事务执行完毕之后，Redis才会处理其他客户端的命令。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br><span class="line"><span class="comment"># QUEUED 说明命令被入队了</span></span><br><span class="line"><span class="built_in">set</span> multitest 100</span><br><span class="line"><span class="comment"># QUEUED</span></span><br><span class="line">get multitest</span><br><span class="line"><span class="comment"># 这时候才真正执行</span></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在exec之前, 如果使用另一个redis-cli来get或者set multitest的话, 是可以正常作用到这个key的</span></span><br></pre></td></tr></table></figure>

<p><code>watch</code>：如果在事务开始之前<code>watch</code>了某个key，那么在事务执行期间，该key的值发生了改变，<code>exec</code>时不会执行事务。</p>
<p>redis事务不保证原子性：</p>
<ul>
<li><p>queue命令时出现错误（如语法错误），整个事务无法执行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br><span class="line"><span class="built_in">set</span> key1 value</span><br><span class="line"><span class="comment"># &quot;QUEUED&quot;</span></span><br><span class="line"></span><br><span class="line">put key2 value</span><br><span class="line"><span class="comment"># 报错，事务不能执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>queue命令时没有出现错误，但是运行时出现错误，错误的命令不执行，其他命令正常执行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br><span class="line"><span class="built_in">set</span> key1 value</span><br><span class="line"><span class="comment"># &quot;QUEUED&quot;</span></span><br><span class="line"></span><br><span class="line">incr key1 </span><br><span class="line"><span class="comment"># &quot;QUEUED&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> key2 value</span><br><span class="line"><span class="comment"># &quot;QUEUED&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行到incr key1时会报错，但是仍然会继续执行set key2 value</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-11-lua脚本"><a href="#2-11-lua脚本" class="headerlink" title="2.11 lua脚本"></a>2.11 lua脚本</h2><p>lua脚本在redis中是原子执行的，执行过程中不会插入其他命令。lua脚本可以帮助用户创造出自己定制的命令，并可以将这些命令常驻在redis内存中，实现复用效果。lua脚本可将多条命令一次性打包，有效地减少网络开销。</p>
<p>使用redis脚本的方式：<code>eval</code>和<code>evalsha</code>，两者的区别是，后者需要先使用<code>load</code>命令将lua脚本加载到redis中，完成后会得到一个sha1，后续执行<code>evalsha sha1 ...</code>即可执行脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> 脚本内容 key个数 key列表 参数列表</span><br></pre></td></tr></table></figure>

<p>lua脚本里面可以使用<code>redis.call(...)</code>来执行redis命令，如<code>redis.call(&quot;set&quot;, &quot;hello&quot;, &quot;world&quot;)</code>。也可使用<code>redis.pcall(...)</code>，两者区别在于：执行失败时，前者脚本执行结束并返回错误，后者忽略错误继续执行脚本。</p>
<h2 id="2-12-pipeline"><a href="#2-12-pipeline" class="headerlink" title="2.12 pipeline"></a>2.12 pipeline</h2><p>命令执行需要经过：发送命令 -&gt; 命令排队 -&gt; 命令执行 -&gt; 返回结果，n个命令需要经过n次该流程。使用pipeline，客户端可以在发送命令时一次性发送所有命令，服务端执行完所有命令后，再一次性将结果返回。由于服务端会缓存命令结果到所有命令都执行完毕，因此命令数量过多时会很耗费内存。</p>
<h2 id="2-13-其他命令"><a href="#2-13-其他命令" class="headerlink" title="2.13 其他命令"></a>2.13 其他命令</h2><ul>
<li><p><code>sort</code>：对列表和集合进行排序，返回排序后的数据（不改变原有数据）：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 排序列表</span></span><br><span class="line">rpush sortforlisttest 10 2 3 9 1</span><br><span class="line"><span class="comment"># 1 2 3 9 10</span></span><br><span class="line"><span class="built_in">sort</span> sortforlisttest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序集合</span></span><br><span class="line">sadd sortforsettest 2 3 1 9 4 10</span><br><span class="line"><span class="comment"># 1 2 3 4 9 10</span></span><br><span class="line"><span class="built_in">sort</span> sortforsettest</span><br></pre></td></tr></table></figure>
</li>
<li><p>键的过期时间：可以通过<code>del key</code>命令显示删除无用的键，也可以为键设置过期时间，让这个键在指定时间后被自动删除</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># persist key: 移除键的过期时间</span></span><br><span class="line"><span class="comment"># ttl key: 查看给定键距离过期还有多少秒</span></span><br><span class="line"><span class="comment"># expire key seconds: 让给定键在指定的秒数之后过期</span></span><br><span class="line"><span class="comment"># expire key timestamp: 让给定的键在timestamp时间戳的时候过期</span></span><br><span class="line"><span class="comment"># pttl key: 距离过期还有多少毫秒</span></span><br><span class="line"><span class="comment"># pexpire key millseconds: 让给定键在指定的毫秒数之后过期</span></span><br><span class="line"><span class="comment"># pexpire key timestamp: 在毫秒级的timestamp时间戳的时候过期</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、持久化"><a href="#三、持久化" class="headerlink" title="三、持久化"></a>三、持久化</h1><p>Redis持久化是将Redis内存数据库中的数据保存到磁盘以便在重启Redis时进行数据恢复的过程。因为Redis是内存数据库，数据通常存储在RAM中，如果没有持久化的过程，服务器重启后数据就全丢了。</p>
<h2 id="3-1-RDB"><a href="#3-1-RDB" class="headerlink" title="3.1 RDB"></a>3.1 RDB</h2><p>RDB文件，一个紧凑压缩的二进制文件，代表Redis在某个时间点上的整个数据集（数据快照）。可手动触发生成或自动触发生成。</p>
<ul>
<li>手动触发：<ul>
<li><code>save</code>命令：阻塞当前Redis服务器，直到RDB过程完成为止，对内存比较大的实例会造成长时间阻塞（因此线上不建议使用）。</li>
<li><code>bgsave</code>命令：Redis进程执行fork操作创建子进程，通过cow来处理持久化逻辑，阻塞只发生在fork阶段，时间很短。</li>
</ul>
</li>
<li>自动触发：<ul>
<li>设置<code>save</code>配置选项: 如<code>save 60 10000</code>会从Redis最近一次创建快照之后开始算起, 当“60秒之内有10000次写入(距离上次成功生成快照已经过了60秒, 且在此期间有超过10000次写入)”这个条件满足的时候, 自动触发<code>BGSAVE</code>命令.</li>
<li>从节点执行全量复制操作，主节点自动执行<code>bgsave</code>生成RDB文件并发送给从节点。</li>
<li>执行<code>shutdown</code>命令时，如果没有开启AOF持久化功能自动执行<code>bgsave</code></li>
</ul>
</li>
</ul>
<p>优缺点：</p>
<ul>
<li>优点：性能高；冷启动快速，因为不需要逐个重放命令。</li>
<li>缺点：数据丢失，如果服务器在两次RDB快照之间崩溃，那么会丢失最后一次快照后的所有数据。</li>
</ul>
<h2 id="3-2-AOF"><a href="#3-2-AOF" class="headerlink" title="3.2 AOF"></a>3.2 AOF</h2><p>以追加日志的方式，将每个写操作追加到日志文件中，记录数据变更的命令。重启时逐个执行AOF文件中的命令即可恢复数据状态。</p>
<p>优缺点：</p>
<ul>
<li>优点：数据完整性高</li>
<li>缺点：性能慢，包括每个命令都要写以及崩溃恢复的逐个命令重放</li>
</ul>
<h1 id="四、主从复制、哨兵、集群"><a href="#四、主从复制、哨兵、集群" class="headerlink" title="四、主从复制、哨兵、集群"></a>四、主从复制、哨兵、集群</h1><h2 id="4-1-主从复制"><a href="#4-1-主从复制" class="headerlink" title="4.1 主从复制"></a>4.1 主从复制</h2><p>分布式系统中为了解决单点问题，通常会把数据复制到多个副本部署到其他机器，满足故障恢复和负载均衡等需求。主从复制下从节点的加入主要解决了两个问题：一是作为从节点的备份，转移主节点的故障。二是读写分离分担主节点的压力。</p>
<h3 id="4-1-1-配置"><a href="#4-1-1-配置" class="headerlink" title="4.1.1 配置"></a>4.1.1 配置</h3><p>参与复制的Redis实例被划分为主节点（master）和从节点（slave）。默认情况下每个节点都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节点。</p>
<p>建立复制：</p>
<ol>
<li>配置文件加入<code>slaveof &#123;masterHost&#125; &#123;masterPort&#125;</code>随Redis启动生效</li>
<li>在redis-server启动命令后加入<code>-slaveof &#123;masterHost&#125; &#123;masterPort&#125;</code>生效</li>
<li>直接使用命令： <code>slaveof &#123;masterHost&#125; &#123;masterPort&#125;</code></li>
</ol>
<p>断开复制：</p>
<ol>
<li>在从节点上执行<code>slaveof no one</code></li>
<li>断开复制之后数据不会被清除，但是如果从新连接主节点，则当前节点数据会被清除</li>
</ol>
<h3 id="4-1-2-拓扑"><a href="#4-1-2-拓扑" class="headerlink" title="4.1.2 拓扑"></a>4.1.2 拓扑</h3><ol>
<li>一主一从：主节点出现宕机时，从节点提供故障转移</li>
<li>一主多从：读写分离，读占比比较多场景都可用，耗时长的读操作可在从服务器做，如<code>keys</code>命令</li>
<li>树状主从：避免多从节点同步对主节点带来性能干扰</li>
</ol>
<h3 id="4-1-3-原理"><a href="#4-1-3-原理" class="headerlink" title="4.1.3 原理"></a>4.1.3 原理</h3><p>从节点使用<code>slaveof</code>命令和主节点建立复制关系之后，复制过程开始运作，整个过程为：</p>
<ol>
<li>保存主节点信息：ip，port，状态等</li>
<li>和主节点建立网络连接</li>
<li>发送ping命令检查网络连接是否可用</li>
<li>主节点将数据全部发送给从节点</li>
<li>从节点获取到初始化数据后，后续主节点会持续将写命令发送给从节点，保证主从数据一致性</li>
</ol>
<p>全量复制：用于初次复制场景，将主节点数据一次性发送给从节点</p>
<p>部分复制：用于主从复制中因网络闪断等原因造成的数据丢失场景，从节点再次连上主节点之后，如果条件允许，主节点会补发数据给从节点。因补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。</p>
<h3 id="4-1-4-故障转移"><a href="#4-1-4-故障转移" class="headerlink" title="4.1.4 故障转移"></a>4.1.4 故障转移</h3><ol>
<li>客户端与主节点的连接失败，从节点与主节点的连接失败，复制中断</li>
<li>挑选一个从节点，执行<code>slaveof no one</code>使其成为新的主节点</li>
<li>更新应用方的主节点信息为新挑选的主节点</li>
<li>使用<code>slaveof</code>命令，让其他从节点去复制新的主节点</li>
<li>原来的主节点恢复后，让他复制新的主节点</li>
</ol>
<h2 id="4-2-哨兵"><a href="#4-2-哨兵" class="headerlink" title="4.2 哨兵"></a>4.2 哨兵</h2><p>主从复制模式下，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址，生产上这种处理方式可用性很差，Redis2.8以后提供的Redis Sentinel架构就是Redis的高可用实现方案，用于处理这种问题。就是说Sentinel的存在就是为了自动处理故障发现和故障转移的。</p>
<p>Sentinel架构：</p>
<ol>
<li>包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余的Sentinel节点进行监控</li>
<li>当发现节点不可达时，会对节点做下线标识，如果被标识的节点是主节点，则会和其他Sentinel节点进行协商</li>
<li>当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，并将这个变化通知Redis应用方</li>
</ol>
<h3 id="4-2-1-Leader节点选举"><a href="#4-2-1-Leader节点选举" class="headerlink" title="4.2.1 Leader节点选举"></a>4.2.1 Leader节点选举</h3><p>对主节点做出客观下线之后，需要一个Sentinel节点来完成故障转移，这个节点由选举得出，选举算法为Raft。</p>
<h2 id="4-3-集群"><a href="#4-3-集群" class="headerlink" title="4.3 集群"></a>4.3 集群</h2><p>Redis的分布式解决方案，有效解决单机内存，并发，流量等瓶颈。思想为：定义范围哈希槽（16384个），集群内每个节点对应一部分的槽，所有的键根据哈希函数映到槽内。</p>
<h3 id="4-3-1-节点通信"><a href="#4-3-1-节点通信" class="headerlink" title="4.3.1 节点通信"></a>4.3.1 节点通信</h3><p>分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和P2P方式。Redis集群采用P2P的Gossip协议，原理是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整信息。</p>
<p>Gossip协议：职责为信息交换，信息交换的载体为节点彼此发送的Gossip消息，类型有ping消息、pong消息、meet消息、fail消息等。</p>
<ul>
<li>meet消息：用于通知新节点加入，消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</li>
<li>ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。ping消息发送封装了自身节点和部分其他节点的状态数据。</li>
<li>pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li>
<li>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息后会把对应节点更新为下线状态。</li>
</ul>
<h3 id="4-3-2-伸缩原理"><a href="#4-3-2-伸缩原理" class="headerlink" title="4.3.2 伸缩原理"></a>4.3.2 伸缩原理</h3><p>Redis集群可以实现对节点的灵活上下线控制，原理可抽象为槽和对应数据在不同节点之间灵活移动。扩容从宏观角度看就是将一些槽分配给新的节点并将属于这些槽的数据移动到新的节点，缩容反之。扩容的步骤为：</p>
<ol>
<li>启动新的节点</li>
<li>使用<code>cluster meet</code>命令将新节点加入集群，此时新加入的节点都是都是主节点，但由于没有负责的槽，不能接受任何读写操作。可以为它迁移槽和数据实现扩容，也可以让它作为其他主节点的从节点负责故障转移</li>
<li>迁移槽和数据（迁移过程集群可以正常提供读写服务）：<ul>
<li>对目标节点发送<code>cluster setslot &#123;slot&#125; importing &#123;sourceNodeId&#125;</code>命令，让目标节点准备导入槽的数据</li>
<li>对源节点发送<code>cluster setslot &#123;slot&#125; migrating &#123;targetNodeId&#125;</code>命令，让源节点准备导出槽的数据</li>
<li>源节点循环执行<code>cluster getkeysinslot &#123;slot&#125; &#123;count&#125;</code>命令，获取count个属于槽<code>&#123;slot&#125;</code>的键</li>
<li>在源节点上执行<code>migrate &#123;targetIp&#125; &#123;targetPort&#125;...</code>命令把获取的键通过流水线机制批量迁移到目标节点上</li>
<li>重复执行步骤三和四直到槽下所有的键值数据迁移到目标节点</li>
<li>向集群内所有主节点发送<code>cluster setslot &#123;slot&#125; node &#123;targetNodeId&#125;</code>命令，通知槽分配给目标节点。为保证槽节点映射变更及时传播，需要遍历发送给所有主节点更新被迁移的槽指向新节点</li>
</ul>
</li>
<li>为扩容的主节点设置从节点</li>
</ol>
<p>上述步骤都要手动执行，可以使用redis-trib工具自动执行</p>
<p>缩容步骤略。</p>
<h3 id="4-3-3-请求路由"><a href="#4-3-3-请求路由" class="headerlink" title="4.3.3 请求路由"></a>4.3.3 请求路由</h3><ol>
<li>集群模式下，Redis接收任何键相关命令时首先计算键对应的槽，再根据槽找出对应的节点，如果节点是自身，则处理键命令，否则回复MOVED重定向错误，通知客户端请求正确的节点。使用redis-cli时加入<code>c</code>参数支持自动重定向。</li>
<li>smart客户端：本地维护slot到节点的映射，每次访问key时，计算key对应的slot就可以拿到节点直接访问，当收到MOVED响应时会更新本地映射。</li>
<li>JedisCluster：Java下的smart客户端</li>
</ol>
<h3 id="4-3-4-故障转移"><a href="#4-3-4-故障转移" class="headerlink" title="4.3.4 故障转移"></a>4.3.4 故障转移</h3><ol>
<li>故障发现：<ul>
<li>集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节点会认为接收节点存在故障，把接收节点标记为主观下线状态</li>
<li>某个节点判断另一个节点主观下线后，相应节点状态会随消息在集群内传播，当半数以上持有槽的主节点都标记某个节点是客观下线时，触发客观下线流程</li>
<li>客观下线：向集群广播一条fail消息，通知所有的节点将故障节点标记为客观下线（谁发的消息？）</li>
</ul>
</li>
<li>故障恢复：故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，从而保证集群高可用。</li>
</ol>
<h1 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h1><p>基本上有几种应用场景：</p>
<ol>
<li>利用Redis数据存储于内存而内存高速读写的特性<ul>
<li>缓存</li>
<li>分布式锁</li>
</ul>
</li>
<li>利用Redis提供的多种数据结构，方便地对数据进行各种计算操作<ul>
<li>排行榜</li>
<li>集合计算</li>
<li>计数器（如库存扣减）</li>
<li>消息队列</li>
</ul>
</li>
</ol>
<h2 id="5-1-缓存"><a href="#5-1-缓存" class="headerlink" title="5.1 缓存"></a>5.1 缓存</h2><h3 id="5-1-1-缓存穿透"><a href="#5-1-1-缓存穿透" class="headerlink" title="5.1.1 缓存穿透"></a>5.1.1 缓存穿透</h3><p>缓存穿透指的是在使用缓存机制的应用中，当某个请求需要获取的数据在缓存中不存在，而且请求是恶意或者频繁的，导致每次请求都要访问后端数据库。</p>
<p>解决方案：</p>
<ul>
<li>第一层使用布隆过滤器：提前哈希数据保存到布隆过滤器中，不存在布隆过滤器中的数据一定不在后端库中，可以直接返回。在布隆过滤器中的键可能也不在库中，但是还会经过第二层过滤</li>
<li>第二层缓存空对象，并设置过期时间，避免使用同一个不存在的key做攻击</li>
</ul>
<h3 id="5-1-2-缓存雪崩"><a href="#5-1-2-缓存雪崩" class="headerlink" title="5.1.2 缓存雪崩"></a>5.1.2 缓存雪崩</h3><p>缓存雪崩是指在缓存中大量的缓存键在同一时间失效（或同时被删除），导致大量的请求直接访问后端存储（如数据库），从而对后端存储造成了巨大的负载压力。</p>
<p>解决方案：</p>
<ul>
<li>设置随机缓存过期时间，避免热点缓存同时失效</li>
</ul>
<h3 id="5-1-3-缓存击穿"><a href="#5-1-3-缓存击穿" class="headerlink" title="5.1.3 缓存击穿"></a>5.1.3 缓存击穿</h3><p>缓存击穿是指在使用缓存的应用程序中，<strong>某个</strong>缓存键的失效或过期导致了大量的请求同时访问后端存储（如数据库），从而对后端存储系统造成了巨大的负载压力。缓存击穿通常是由于热点数据的高并发访问和缓存中的数据失效引起的。</p>
<p>解决方案：</p>
<ul>
<li>热点键设置永不过期</li>
</ul>
<h2 id="5-2-分布式锁"><a href="#5-2-分布式锁" class="headerlink" title="5.2 分布式锁"></a>5.2 分布式锁</h2><ul>
<li>使用<code>setnx</code>命令加锁：<ul>
<li>为防止死锁，需要设置过期时间</li>
<li>设置过期时间和加锁不是一个原子操作, 期间宕机会导致死锁, 使用lua脚本</li>
<li>新版本可使用set命令加锁, 加上px和nx参数, 可避免使用lua脚本</li>
</ul>
</li>
<li>加锁的key为锁的key，value为标识当前线程的uuid，作用：解锁时根据该值判断是否当前线程加的锁，从而防止锁过期后其他线程拿到了锁，然后当前线程又误释放了别人的锁</li>
<li>解锁：判断值是否当前线程才解锁，因为可能执行时间超过超时时间，锁已经释放了，另外判断锁是否当前线程持有再解锁也不是原子操作，需要用lua脚本</li>
<li>续期线程：续期锁过期时间，但也有可能下一个续期时间还没到，锁已经过期了，续期不了，所以加锁时设置value为线程的uuid还是必要的</li>
<li>加锁失败：如果当前获取锁的线程是当前进程，则线程移到等待队列，挂起；如果获取锁的线程不是当前进程，则启动重试线程，隔一段时间去看一下锁对应的键在不在，不在说明被释放了，可唤醒当前进程等待队列的头部线程，去竞争锁。</li>
</ul>
<h2 id="5-3-计数器"><a href="#5-3-计数器" class="headerlink" title="5.3 计数器"></a>5.3 计数器</h2><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="6-1-运维"><a href="#6-1-运维" class="headerlink" title="6.1 运维"></a>6.1 运维</h2><h3 id="6-1-1-概念"><a href="#6-1-1-概念" class="headerlink" title="6.1.1 概念"></a>6.1.1 概念</h3><ul>
<li><p>Redis工作线程模型为单线程</p>
</li>
<li><p>Redis单机每秒支持10万QPS</p>
</li>
<li><p>慢查询：Redis中慢查询统计只统计命令执行的耗时，命令传输及命令排队耗时不会统计。<code>slowlog-log-slower-than</code>表示执行时间长于这个值就记录相应的命令，单位为微秒。命令存放点为一个列表，<code>slowlog-max-len</code>这个命令表示那个列表的长度为多少，超过该长度则移除表头元素。操作方式：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置</span></span><br><span class="line"><span class="comment"># 方式一：命令</span></span><br><span class="line">config <span class="built_in">set</span> slowlog-log-slower-than 20000</span><br><span class="line">config <span class="built_in">set</span> slowlog-max-len 1000</span><br><span class="line"><span class="comment"># 将配置持久化到本地文件</span></span><br><span class="line">config rewrite</span><br><span class="line"><span class="comment"># 方式二：配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line"><span class="comment"># 慢查询列表</span></span><br><span class="line">slowlog get</span><br><span class="line"><span class="comment"># 慢查询列表长度</span></span><br><span class="line">slowlog len</span><br><span class="line"><span class="comment"># 慢查询日志重置（即清空慢日志列表）</span></span><br><span class="line">slowlog reset</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-1-2-命令"><a href="#6-1-2-命令" class="headerlink" title="6.1.2 命令"></a>6.1.2 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有键</span></span><br><span class="line">keys *</span><br><span class="line"><span class="comment"># 键总数</span></span><br><span class="line">dbsize</span><br><span class="line"><span class="comment"># 检查键是否存在</span></span><br><span class="line">exists key</span><br><span class="line"><span class="comment"># 删除键</span></span><br><span class="line">del key</span><br><span class="line"><span class="comment"># 键过期</span></span><br><span class="line">expire key seconds</span><br><span class="line"><span class="comment"># 键类型</span></span><br><span class="line"><span class="built_in">type</span> key</span><br><span class="line"><span class="comment"># 内部编码类型</span></span><br><span class="line">object encoding key</span><br><span class="line"><span class="comment"># 键重命名</span></span><br><span class="line">rename key newkey</span><br><span class="line"><span class="comment"># 随机返回一个键</span></span><br><span class="line">randomkey</span><br><span class="line"><span class="comment"># 键过期</span></span><br><span class="line">expire key seconds</span><br><span class="line">expireat key timestamp</span><br><span class="line"><span class="comment"># 查询剩余过期时间</span></span><br><span class="line">ttl</span><br><span class="line">pttl</span><br><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">select dbIndex</span><br><span class="line"><span class="comment"># 清除数据库</span></span><br><span class="line">flushdb <span class="comment"># 清除当前数据库</span></span><br><span class="line">flushall <span class="comment"># 清除所有数据库</span></span><br><span class="line"><span class="comment"># 查看内存消耗情况</span></span><br><span class="line">info memory</span><br></pre></td></tr></table></figure>

<h3 id="6-1-3-内存回收策略"><a href="#6-1-3-内存回收策略" class="headerlink" title="6.1.3 内存回收策略"></a>6.1.3 内存回收策略</h3><ol>
<li>删除过期键对象：<ul>
<li>惰性删除：对键进行操作时，若发现键已经过期则删除键并取消执行</li>
<li>定时删除：定期到过期字典拿key，判断是否过期，若是则删除它</li>
</ul>
</li>
<li>内存溢出控制策略：当Redis所用内存达到maxmemory上限时，触发相应的溢出控制策略：<ul>
<li>noeviction：默认策略，不会删除任何数据，拒绝写入并返回客户端错误信息</li>
<li>volatile-lru：根据lru算法删除设置了超时属性的键，直到腾出足够空间，如果没有可删除的键，回退到noeviction策略</li>
<li>allkeys-lru：根据lru算法删除键，不管数据是否设置过期时间，直到腾出足够空间为止</li>
<li>volatile-random：随机删除过期键，直到腾出空间为止</li>
<li>allkeys-random：随机删除所有键，直到腾出足够空间为止</li>
<li>volatile-ttl：根据减值对象的ttl属性，删除最近要过期的数据，如果没有，回退到noeviction策略</li>
</ul>
</li>
</ol>
<p>内存溢出控制策略设置方式为：<code>config set maxmemory-policy &#123;policy&#125;</code>，如：<code>config set maxmemory-policy volatile-ttl</code></p>
<h2 id="6-2-参考资料"><a href="#6-2-参考资料" class="headerlink" title="6.2 参考资料"></a>6.2 参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://redis.io/documentation">redis官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022808576">你了解 Redis 的三种集群模式吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903661223542792">深入剖析Redis系列</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c869feb5581d">Redis集群的原理和搭建</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903817796911112">50道Redis面试题史上最全，以后面试再也不怕问Redis了</a></li>
<li>书籍：Redis开发与运维，<a target="_blank" rel="noopener" href="https://www.processon.com/mindmap/61f7afc60e3e7407d4beab40">Redis设计与实现</a>，<a target="_blank" rel="noopener" href="https://www.processon.com/mindmap/621b54f11e08533fc3b0e5f0">掘金小册”Redis深度历险”</a>，<a target="_blank" rel="noopener" href="https://www.processon.com/mindmap/621b5438e401fd520c17fa1f">极客时间“Redis核心技术与实战”</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://alpha2j.cn">Jeb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://alpha2j.cn/2021/08/20/undefined/">https://alpha2j.cn/2021/08/20/undefined/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://alpha2j.cn" target="_blank">杰布是谁</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/notes/">notes</a><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="/assets/blog_avatar.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/12/undefined/" title="雪花算法原理与Java实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">雪花算法原理与Java实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/22/undefined/" title="MySQL知识点总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL知识点总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/05/27/undefined/" title="Docker"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-28</div><div class="title">Docker</div></div></a></div><div><a href="/2020/05/29/undefined/" title="Git"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-30</div><div class="title">Git</div></div></a></div><div><a href="/2020/06/24/undefined/" title="正则表达式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-25</div><div class="title">正则表达式</div></div></a></div><div><a href="/2020/07/17/undefined/" title="JavaScript基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-18</div><div class="title">JavaScript基础</div></div></a></div><div><a href="/2020/07/19/undefined/" title="ES6"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-20</div><div class="title">ES6</div></div></a></div><div><a href="/2021/04/22/undefined/" title="MySQL知识点总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-23</div><div class="title">MySQL知识点总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/blog_avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jeb</div><div class="author-info__description">即使天还没亮，固执做梦的人，身前会有光！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Alpha2J"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Alpha2J" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jeb.wannng@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E5%8F%8AJedis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.</span> <span class="toc-text">一、安装、配置及Jedis客户端</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">二、基本功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AD%97%E7%AC%A6%E4%B8%B2-string"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 字符串(string)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%88%97%E8%A1%A8-list"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 列表(list)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E9%9B%86%E5%90%88-set"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 集合(set)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%93%88%E5%B8%8C-hash"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 哈希(hash)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-zset"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 有序集合(zset)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-bitmaps"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 bitmaps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-hyperloglog"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 hyperloglog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-geo"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 geo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 发布订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.10.</span> <span class="toc-text">2.10 事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-lua%E8%84%9A%E6%9C%AC"><span class="toc-number">2.11.</span> <span class="toc-text">2.11 lua脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-pipeline"><span class="toc-number">2.12.</span> <span class="toc-text">2.12 pipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-number">2.13.</span> <span class="toc-text">2.13 其他命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">三、持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-RDB"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 RDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-AOF"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 AOF</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E3%80%81%E5%93%A8%E5%85%B5%E3%80%81%E9%9B%86%E7%BE%A4"><span class="toc-number">4.</span> <span class="toc-text">四、主从复制、哨兵、集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%8B%93%E6%89%91"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 拓扑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4 故障转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%93%A8%E5%85%B5"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-Leader%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 Leader节点选举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%9B%86%E7%BE%A4"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 节点通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E4%BC%B8%E7%BC%A9%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 伸缩原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 请求路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4 故障转移</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">五、应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%BC%93%E5%AD%98"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3 缓存击穿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 计数器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">6.</span> <span class="toc-text">六、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E8%BF%90%E7%BB%B4"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 运维</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3 内存回收策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 参考资料</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/17/undefined/" title="使用bitcoinjs-lib进行比特币的转账">使用bitcoinjs-lib进行比特币的转账</a><time datetime="2023-12-17T16:00:00.000Z" title="发表于 2023-12-18 00:00:00">2023-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/06/the-syllabus/" title="Tuesday with Morrie Chapter2 The Syllabus">Tuesday with Morrie Chapter2 The Syllabus</a><time datetime="2023-08-06T16:00:00.000Z" title="发表于 2023-08-07 00:00:00">2023-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/04/the-curriculum/" title="Tuesday with Morrie Chapter1 The Curriculum">Tuesday with Morrie Chapter1 The Curriculum</a><time datetime="2023-08-04T16:00:00.000Z" title="发表于 2023-08-05 00:00:00">2023-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/undefined/" title="如何创建自己的maven archetype">如何创建自己的maven archetype</a><time datetime="2023-07-25T16:00:00.000Z" title="发表于 2023-07-26 00:00:00">2023-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/07/undefined/" title="maven核心概念的一次探索">maven核心概念的一次探索</a><time datetime="2023-07-07T16:00:00.000Z" title="发表于 2023-07-08 00:00:00">2023-07-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Jeb</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>